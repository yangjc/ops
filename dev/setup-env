#!/usr/bin/env bash
# YJC <yangjiecong@live.com>

# 替换环境变量
## 对当前目录下的.gitignore列出的文件，查找对应的模板文件
## 例如目标文件 filename.ext ，其模板文件为 filename.envtpl.ext
## 如果存在模板文件，替换里面的 ${ENV_NAME} 为对应的值，然后写入目标文件
## 忽略备份文件 *.envbackup-*

# 环境变量文件：env-name.env
## 文件格式为每行一个键值对，等号分隔：变量名=值
## 变量名只允许字母、数字、下划线
## 如果一个值包含换行符，则下一行变量名留空

envFile="$1"
listFile="$2"

if [ -z "$envFile" ]; then
    echo "Usage
    $(basename "$0") env-file [list-file]
        如果指定了 [list-file] ，工作目录为 [list-file] 所在的目录；
        否则工作目录为当前目录，此时 [list-file=.gitignore] 。
"
    exit 1
fi

envTplName="envtpl"
envBkName="envbackup-"
envDir="$(dirname "$envFile")"
envFile="$envDir/$(basename "$envFile")"
sampleFile="$envDir/sample.env"

if [ "$envFile" == "$sampleFile" ]; then
    echo "don't use \`$sampleFile\` as env file" >&2
    exit 1
fi

if [ -n "$listFile" ]; then
    if [ ! -f "$listFile" ]; then
        echo "\`$listFile\` list file not found" >&2
        exit 1
    fi
    cd "$(dirname "$listFile")"
else
    listFile=.gitignore
fi

if [ ! -f "$envFile" ]; then
    echo "\`$envFile\` env file not found" >&2
    exit 1
fi

echo "work directory: $(pwd)"
echo "list file: $listFile"
echo "read env variables from \`$envFile\`"

> "$sampleFile"
declare -A envVars
lastKey=
n=0
while IFS=$'\n' read -r line || [ -n "$line" ]; do
    n="$((n+1))"
    if [[ "$line" != *"="* ]] || [ -z "$line" ]; then
        # 跳过不包含等号的行和空行
        echo "ignore line[$n] in \`$envFile\`" >&2
        continue
    fi

    # 取第一个等号前面的字符串为变量名
    k="${line%%=*}"

    # 变量名只允许字母、数字、下划线
    if ! [[ "$k" =~ ^(|[0-9a-zA-Z_]+)$ ]]; then
        echo "ignore line[$n] in \`$envFile\`, unexpected name" >&2
    fi

    # 第一个等号后面的字符串为值
    v="${line#*=}"

    if [ -z "$k" ]; then
        if [ -z "$lastKey" ]; then
            echo "ignore line[$n] in \`$envFile\`" >&2
            continue
        else
            # 如果变量名为空，则把值换行后拼接到前一个变量
            envVars[$lastKey]="${envVars[$lastKey]}\n${v}"
        fi
    else
        envVars[$k]="$v"
        lastKey="$k"

        echo "${k}=" >> "$sampleFile"
    fi
done < "$envFile"

setFile() {
    envTpl="$1"
    targetFile="$2"
    fileNoExt="$3"
    fileExt="$4"
    echo "replace env values: \`$envTpl\` -> \`$targetFile\`"

    tplMTime="$(stat -c %Y "$envTpl")"
    if [ -f "$targetFile" ]; then
        targetMTime="$(stat -c %Y "$targetFile")"
    else
        targetMTime="0"
    fi

    # 如果目标文件修改时间大于模板文件，则备份
    if [ "$targetMTime" -gt "$tplMTime" ]; then
        bkFile="${fileNoExt}.${envBkName}${targetMTime}${fileExt}"
        echo "backup target file to \`$bkFile\`"
        cat "$targetFile" > "$bkFile"
    fi

    cat "$envTpl" > "$targetFile"
    for k in "${!envVars[@]}"
    do
        v="${envVars[$k]}"
        sed -i -e s/\${"$k"}/"${v//\//\\/}"/ "$targetFile"
    done

    # 使目标文件的修改时间和模板文件的修改时间一致
    touch -mt "$(date +%Y%m%d%H%M.%S -d "@$tplMTime")" "$targetFile"
}

setFiles() {
    listFile="$1"
    if [ ! -f "$listFile" ]; then
        echo "\`$listFile\` list file not found" >&2
        return 1
    fi

    echo "start replace env values of files in \`$listFile\`"

    n=0
    while IFS= read -r f || [ -n "$f" ]; do
        n="$((n+1))"

        # 避免查找根目录
        [ "${f:0:1}" == '/' ] && f="${f:1}"

        if [[ "$f" =~ ^[#!] ]] || [[ "$f" == *'*'* ]] || [ -z "$f" ] || [ -d "$f" ] || [ -L "$f" ]; then
            # 跳过注释、非（!）、通配符、空、文件夹、链接
            echo "ignore line[$n] \`$f\` in \`$listFile\`" >&2
            continue
        fi

        # 取文件名后缀
        ext="${f##*.}"
        fileNoExt="$f"
        if [ "$f" == "$ext" ]; then
            ext=""
            # 没有后缀的文件名，附加信息直接拼接到最后
        else
            ext=".${ext}"
            fileNoExt="${f%.*}"
            # 有后缀的文件名，附加信息拼接到后缀前面
        fi
        envTpl="${fileNoExt}.${envTplName}${ext}"

        if [ -f "$envTpl" ]; then
            setFile "$envTpl" "$f" "$fileNoExt" "$ext"
        else
            echo "ignore line[$n] \`$f\` in \`$listFile\`, \`$envTpl\` not found" >&2
        fi
    done < "$listFile"
}

setFiles "$listFile"
